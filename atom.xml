<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Learning Blog]]></title>
  <link href="http://fubuki.github.io/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2015-02-01T23:54:10+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leveldb 感想]]></title>
    <link href="http://fubuki.github.io/blog/2015/02/01/leveldb/"/>
    <updated>2015-02-01T23:47:53+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/02/01/leveldb</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://github.com/google/leveldb">Leveldb</a> 是一個 key-value 的儲存系統，是將資料直接存放在硬碟上而不是記憶體上面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WhatsApp 的架構]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/31/whatapp/"/>
    <updated>2015-01-31T23:06:37+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/31/whatapp</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html">How WhatsApp Grew to Nearly 500 Million Users, 11,000 cores, and 70 Million Messages a Second</a>
<a href="https://www.youtube.com/watch?v=c12cYAUTXXs">Erlang Factory 2014 - That&rsquo;s &lsquo;Billion&rsquo; with a &lsquo;B&rsquo;: Scaling to the Next Level at WhatsApp</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二月書單]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/30/2015-2-booklist/"/>
    <updated>2015-01-30T23:16:18+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/30/2015-2-booklist</id>
    <content type="html"><![CDATA[<!-- more -->


<ol>
<li>搜索引擎：信息檢索實踐</li>
<li>鏈結分析</li>
<li>Mastering OpenCV with Practical Computer Vision Projects</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Torch 平台]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/29/facebook-torch/"/>
    <updated>2015-01-29T23:38:26+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/29/facebook-torch</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://torch.ch">torch</a> 是一個 Machine learning 平台，裡面支援不少演算法， <a href="https://research.facebook.com/ai">FAIR</a> 最近放出基於這個平台的工具:<a href="https://github.com/facebook/fbcunn">fbcunn</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSON-LD]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/28/json-ld/"/>
    <updated>2015-01-28T23:29:21+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/28/json-ld</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://json-ld.org/">JSON for Linking Data</a> 在 JSON 上面添加新的規格，似乎是希望讓機器能夠更有效的處理資料。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event Sourcing Pattern]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/27/event-sourcing-pattern/"/>
    <updated>2015-01-27T23:03:23+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/27/event-sourcing-pattern</id>
    <content type="html"><![CDATA[<!-- more -->


<p>之前在看 LMAX 的架構的時候，提到利用 <code>Event Sourcing</code> 這個模式開發程式可以完全在記憶體裡面運算，提升程式運算的效能，
那個時候尚未了解 <code>Event Sourcing</code> 是何物，今天就紀錄一下研究的資料: <a href="http://ookami86.github.io/event-sourcing-in-practice/">Event Sourcing in practice</a>。</p>

<p><a href="http://ookami86.github.io/event-sourcing-in-practice/">Event Sourcing in practice</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 開發環境]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/26/golang-kai-fa-huan-jing/"/>
    <updated>2015-01-26T23:37:12+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/26/golang-kai-fa-huan-jing</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://golang.org/doc/code.html">How to Write Go Code</a> 要先了解 go 的目錄結構，目前有個 wide 的 web ide 可以測試看看。</p>

<pre><code>apt-get install gccgo-go
mkdir mygo
export GOPATH=~/mygo
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 的 Worker_cpu_affinity 參數]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/25/nginx-worker-cpu-affinity/"/>
    <updated>2015-01-25T21:13:34+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/25/nginx-worker-cpu-affinity</id>
    <content type="html"><![CDATA[<!-- more -->


<p>nginx 可以藉由使用 <code>worker_cpu_affinity</code> 在多核分配進程在哪幾顆 CPU 下執行。</p>

<p>四核四個進程</p>

<pre><code>worker_processes 4;
worker_cpu_affinity 1000 0100 0010 0001;
</code></pre>

<p>四核兩個進程</p>

<pre><code>worker_processes 2;
worker_cpu_affinity 1000 0001;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[鏈結分析 : SocSciBot]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/24/socscibot/"/>
    <updated>2015-01-24T22:44:44+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/24/socscibot</id>
    <content type="html"><![CDATA[<!-- more -->


<p>鏈結分析用的程式 <a href="http://socscibot.wlv.ac.uk/">socscibot</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Category Theory]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/23/category-theory/"/>
    <updated>2015-01-23T23:18:18+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/23/category-theory</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在國外一場研討會看到一篇 <a href="http://alissapajer.github.io/conferenceslides/craftconf2014/#/">Functional Examples from Category Theory</a> 的議程是跟數學的 <a href="http://en.wikipedia.org/wiki/Category_theory">Category theory</a> 有關的東西，
正好跟最近在看的<code>細胞自動機</code>和<code>語義學習</code>有關，因此記錄一下。</p>

<p>日本那邊的 Category Theory 學習資料: <a href="http://nineties.github.io/category-seminar/#/">2013年 圏論勉強会 資料</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Barabási–Albert Model]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/22/barabasi-albert-model/"/>
    <updated>2015-01-22T23:44:55+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/22/barabasi-albert-model</id>
    <content type="html"><![CDATA[<!-- more -->


<p>複雜網路理論</p>

<p><a href="http://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[討厭 PHP 的原因]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/21/do-a-large-majority-of-people-hate-php-solely-because-other-people-do-so/"/>
    <updated>2015-01-21T22:39:09+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/21/do-a-large-majority-of-people-hate-php-solely-because-other-people-do-so</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://www.quora.com/Do-a-large-majority-of-people-hate-PHP-solely-because-other-people-do-so">Do a large majority of people hate PHP solely because other people do so</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小世界理論]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/20/small-world-network/"/>
    <updated>2015-01-20T23:46:05+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/20/small-world-network</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://en.wikipedia.org/wiki/Small-world_network">Small-world network</a></p>

<p>冪定律</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Performance Patterns]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/19/android-performance-patterns/"/>
    <updated>2015-01-19T23:20:54+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/19/android-performance-patterns</id>
    <content type="html"><![CDATA[<!-- more -->


<p>一系列關於 Android 性能的影片: <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu">Android Performance Patterns</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HITS Algorithm]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/18/hits-algorithm/"/>
    <updated>2015-01-18T22:16:05+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/18/hits-algorithm</id>
    <content type="html"><![CDATA[<!-- more -->


<p>HITS(Hyperlink lnduccd Topic Search)算法根據 URL 的演算法，跟 Page Rank 不同的地方是 HITS 針對已搜尋出來了的結果
進行排序，所以會每次的查詢都會計算一次結果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Taskset 指令]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/17/linux-taskset/"/>
    <updated>2015-01-17T23:20:43+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/17/linux-taskset</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Linux 有個 taskset 指令可以在多核環境下指定特定的 Process 在某個 CPU 下運行，這個指令是看到有人用在 node.js 腳本上，
由於 node.js 本身如果沒有特別處理是無法發揮多核的效能，所以建立多個 node.js Process 然後個別指定每個 CPU 上面，這樣
就可以將使用到多核的效能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LMAX Architecture]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/16/lmax-architecture/"/>
    <updated>2015-01-16T22:37:48+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/16/lmax-architecture</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://martinfowler.com/articles/lmax.html">The LMAX Architecture</a> 一個高吞吐量的金融交易平台，是由 LMAX Exchange 基於 JVM 所建立的架構，文章裡面提到一些他們如何做到每秒六百萬訂單的
方法，另外這邊有 <a href="http://www.infoq.com/presentations/LMAX">LMAX - How to Do 100K TPS at Less than 1ms Latency</a> 文章作者的演講。</p>

<ol>
<li>Event Source</li>
<li>全都在記憶體裡面運算</li>
<li>由於 Event Source 的關係要另外處理持久化的問題</li>
<li>Disruptor 的 RingBuffer 結構</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sql Join 的類型]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/15/sql-join/"/>
    <updated>2015-01-15T22:51:10+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/15/sql-join</id>
    <content type="html"><![CDATA[<!-- more -->


<p>今天看到一篇關於介紹 sql join 的文章 <a href="http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins">Visual Representation of SQL Joins</a>，裡面把所有的 join 形式解說一遍，並且
有程式碼和圖片搭配，看完就可以了解怎麼使用 sql 的 join 語法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 掛載 Samba 目錄的方法]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/14/linux-mount-samba/"/>
    <updated>2015-01-14T23:19:07+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/14/linux-mount-samba</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近幫人建立一個根據正式機的鏡像系統，需要掛載在多台主機掛載相同的目錄，所以紀錄一下掛載的方法，
以前有用 <code>smbfs</code> 掛載但是比較新的版本似乎只能用 <code>cifs</code>。</p>

<pre><code>mount -t cifs -o username="root",password="toor" //host ip/srv /srv
umount /srv
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Single User Mode 修改 Linux 密碼]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/13/linux-single-user-mode/"/>
    <updated>2015-01-13T22:19:55+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/13/linux-single-user-mode</id>
    <content type="html"><![CDATA[<!-- more -->


<p>之前在管理虛擬機的時候有些機器以前人部署的，所以完全無法得知登入密碼，後來透過網路得知 Linux 有個
 <code>Single User Mode</code> 可以讓使用者這個模式不用密碼登入主機，然後就可以透過 <code>passwd</code> 更改密碼。</p>

<p> 要進入 <code>Single User Mode</code> 是要在開機時在 Grub 選單在開機的指令後面加上 single 參數，然後 ctrl + x 開機
 就會進入 <code>Single User Mode</code> ，但是在我的 ubuntu 14.04 LTS 上面測試卻行不通，會顯示 <code>give root password for maintenance single</code>
 這串訊息，這時就要用另外一種方法。</p>

<p> 如果使用 single 參數行不通就換成 <code>rw init=/bin/bash</code>， 然後按下 ctrl + x 開機就會直接進去主機，之後使用 passwd 更改密碼即可。</p>
]]></content>
  </entry>
  
</feed>
