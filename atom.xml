<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Learning Blog]]></title>
  <link href="http://fubuki.github.io/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2015-01-28T23:45:52+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JSON-LD]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/28/json-ld/"/>
    <updated>2015-01-28T23:29:21+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/28/json-ld</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://json-ld.org/">JSON for Linking Data</a> 在 JSON 上面添加新的規格，似乎是希望讓機器能夠更有效的處理資料。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event Sourcing Pattern]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/27/event-sourcing-pattern/"/>
    <updated>2015-01-27T23:03:23+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/27/event-sourcing-pattern</id>
    <content type="html"><![CDATA[<!-- more -->


<p>之前在看 LMAX 的架構的時候，提到利用 <code>Event Sourcing</code> 這個模式開發程式可以完全在記憶體裡面運算，提升程式運算的效能，
那個時候尚未了解 <code>Event Sourcing</code> 是何物，今天就紀錄一下研究的資料: <a href="http://ookami86.github.io/event-sourcing-in-practice/">Event Sourcing in practice</a>。</p>

<p><a href="http://ookami86.github.io/event-sourcing-in-practice/">Event Sourcing in practice</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 開發環境]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/26/golang-kai-fa-huan-jing/"/>
    <updated>2015-01-26T23:37:12+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/26/golang-kai-fa-huan-jing</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://golang.org/doc/code.html">How to Write Go Code</a> 要先了解 go 的目錄結構，目前有個 wide 的 web ide 可以測試看看。</p>

<pre><code>apt-get install gccgo-go
mkdir mygo
export GOPATH=~/mygo
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 的 Worker_cpu_affinity 參數]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/25/nginx-worker-cpu-affinity/"/>
    <updated>2015-01-25T21:13:34+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/25/nginx-worker-cpu-affinity</id>
    <content type="html"><![CDATA[<!-- more -->


<p>nginx 可以藉由使用 <code>worker_cpu_affinity</code> 在多核分配進程在哪幾顆 CPU 下執行。</p>

<p>四核四個進程</p>

<pre><code>worker_processes 4;
worker_cpu_affinity 1000 0100 0010 0001;
</code></pre>

<p>四核兩個進程</p>

<pre><code>worker_processes 2;
worker_cpu_affinity 1000 0001;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[鏈結分析 : SocSciBot]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/24/socscibot/"/>
    <updated>2015-01-24T22:44:44+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/24/socscibot</id>
    <content type="html"><![CDATA[<!-- more -->


<p>鏈結分析用的程式 <a href="http://socscibot.wlv.ac.uk/">socscibot</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Category Theory]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/23/category-theory/"/>
    <updated>2015-01-23T23:18:18+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/23/category-theory</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在國外一場研討會看到一篇 <a href="http://alissapajer.github.io/conferenceslides/craftconf2014/#/">Functional Examples from Category Theory</a> 的議程是跟數學的 <a href="http://en.wikipedia.org/wiki/Category_theory">Category theory</a> 有關的東西，
正好跟最近在看的<code>細胞自動機</code>和<code>語義學習</code>有關，因此記錄一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Barabási–Albert Model]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/22/barabasi-albert-model/"/>
    <updated>2015-01-22T23:44:55+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/22/barabasi-albert-model</id>
    <content type="html"><![CDATA[<!-- more -->


<p>複雜網路理論</p>

<p><a href="http://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model">Barabási–Albert model</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[討厭 PHP 的原因]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/21/do-a-large-majority-of-people-hate-php-solely-because-other-people-do-so/"/>
    <updated>2015-01-21T22:39:09+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/21/do-a-large-majority-of-people-hate-php-solely-because-other-people-do-so</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://www.quora.com/Do-a-large-majority-of-people-hate-PHP-solely-because-other-people-do-so">Do a large majority of people hate PHP solely because other people do so</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小世界理論]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/20/small-world-network/"/>
    <updated>2015-01-20T23:46:05+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/20/small-world-network</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://en.wikipedia.org/wiki/Small-world_network">Small-world network</a></p>

<p>冪定律</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Performance Patterns]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/19/android-performance-patterns/"/>
    <updated>2015-01-19T23:20:54+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/19/android-performance-patterns</id>
    <content type="html"><![CDATA[<!-- more -->


<p>一系列關於 Android 性能的影片: <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu">Android Performance Patterns</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HITS Algorithm]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/18/hits-algorithm/"/>
    <updated>2015-01-18T22:16:05+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/18/hits-algorithm</id>
    <content type="html"><![CDATA[<!-- more -->


<p>HITS(Hyperlink lnduccd Topic Search)算法根據 URL 的演算法，跟 Page Rank 不同的地方是 HITS 針對已搜尋出來了的結果
進行排序，所以會每次的查詢都會計算一次結果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Taskset 指令]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/17/linux-taskset/"/>
    <updated>2015-01-17T23:20:43+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/17/linux-taskset</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Linux 有個 taskset 指令可以在多核環境下指定特定的 Process 在某個 CPU 下運行，這個指令是看到有人用在 node.js 腳本上，
由於 node.js 本身如果沒有特別處理是無法發揮多核的效能，所以建立多個 node.js Process 然後個別指定每個 CPU 上面，這樣
就可以將使用到多核的效能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LMAX Architecture]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/16/lmax-architecture/"/>
    <updated>2015-01-16T22:37:48+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/16/lmax-architecture</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://martinfowler.com/articles/lmax.html">The LMAX Architecture</a> 一個高吞吐量的金融交易平台，是由 LMAX Exchange 基於 JVM 所建立的架構，文章裡面提到一些他們如何做到每秒六百萬訂單的
方法，另外這邊有 <a href="http://www.infoq.com/presentations/LMAX">LMAX - How to Do 100K TPS at Less than 1ms Latency</a> 文章作者的演講。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sql Join 的類型]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/15/sql-join/"/>
    <updated>2015-01-15T22:51:10+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/15/sql-join</id>
    <content type="html"><![CDATA[<!-- more -->


<p>今天看到一篇關於介紹 sql join 的文章 <a href="http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins">Visual Representation of SQL Joins</a>，裡面把所有的 join 形式解說一遍，並且
有程式碼和圖片搭配，看完就可以了解怎麼使用 sql 的 join 語法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 掛載 Samba 目錄的方法]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/14/linux-mount-samba/"/>
    <updated>2015-01-14T23:19:07+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/14/linux-mount-samba</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近幫人建立一個根據正式機的鏡像系統，需要掛載在多台主機掛載相同的目錄，所以紀錄一下掛載的方法，
以前有用 <code>smbfs</code> 掛載但是比較新的版本似乎只能用 <code>cifs</code>。</p>

<pre><code>mount -t cifs -o username="root",password="toor" //host ip/srv /srv
umount /srv
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Single User Mode 修改 Linux 密碼]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/13/linux-single-user-mode/"/>
    <updated>2015-01-13T22:19:55+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/13/linux-single-user-mode</id>
    <content type="html"><![CDATA[<!-- more -->


<p>之前在管理虛擬機的時候有些機器以前人部署的，所以完全無法得知登入密碼，後來透過網路得知 Linux 有個
 <code>Single User Mode</code> 可以讓使用者這個模式不用密碼登入主機，然後就可以透過 <code>passwd</code> 更改密碼。</p>

<p> 要進入 <code>Single User Mode</code> 是要在開機時在 Grub 選單在開機的指令後面加上 single 參數，然後 ctrl + x 開機
 就會進入 <code>Single User Mode</code> ，但是在我的 ubuntu 14.04 LTS 上面測試卻行不通，會顯示 <code>give root password for maintenance single</code>
 這串訊息，這時就要用另外一種方法。</p>

<p> 如果使用 single 參數行不通就換成 <code>rw init=/bin/bash</code>， 然後按下 ctrl + x 開機就會直接進去主機，之後使用 passwd 更改密碼即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 安裝 Zsh]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/12/linux-zsh/"/>
    <updated>2015-01-12T23:26:31+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/12/linux-zsh</id>
    <content type="html"><![CDATA[<!-- more -->


<p>安裝 zsh</p>

<pre><code>apt-get install zsh
</code></pre>

<p>安裝 <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a></p>

<pre><code>wget --no-check-certificate http://install.ohmyz.sh -O - | bash
</code></pre>

<p>重啟後就可以看到效果了，但是有些安裝的命令卻無法使用還需要測試。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 VM 上面安裝 GNURadio]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/11/gnuradio/"/>
    <updated>2015-01-11T20:09:42+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/11/gnuradio</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近開始玩起 SDR 接收無線電訊號，於是另外安裝安裝 <a href="http://gnuradio.microembedded.com/">GNU Radio</a> 用來處理無線電訊號，一開始
是使用安裝好的 Live cd 測試能否接收到訊號，測試沒問題後就透過 <a href="http://gnuradio.org/redmine/projects/gnuradio/wiki/UbuntuInstall">UbuntuInstall</a> 這篇教學自行安裝。</p>

<p><a href="http://gnuradio.microembedded.com/">GNU Radio</a> 可以透過圖形直接對接收到的訊號進行處理，也可以透過 Python 撰寫程式碼，不過需要先去
複習大學的數位訊號處理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C 語言的巨集]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/10/define-multi-line/"/>
    <updated>2015-01-10T22:43:00+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/10/define-multi-line</id>
    <content type="html"><![CDATA[<!-- more -->


<p>之前在研究 Phalcon 的語法時看到下面這種定義巨集的程式碼，跟以前直接用大括號寫成 Function 的方式不一樣，
後來在別人的網誌看到這兩種的差別，直接使用 Function 的區塊寫法如果沒有注意寫法在預編譯的時候展開可能導致錯誤。</p>

<pre><code>/** Get the current hash key without copying the hash key */
#define PHALCON_GET_HKEY(var, hash, hash_position) \
    do { \
        PHALCON_INIT_NVAR_PNULL(var); \
        phalcon_get_current_key(&amp;var, hash, &amp;hash_position TSRMLS_CC); \
    } while (0)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Information Foraging]]></title>
    <link href="http://fubuki.github.io/blog/2015/01/09/information-foraging-theory/"/>
    <updated>2015-01-09T23:08:32+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/01/09/information-foraging-theory</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近在 <code>設計搜索體驗：搜索的藝術與科學</code> 這本書的 <code>Information Seeking</code> 的章節看到這個名詞 <code>Information Foraging</code>，
網路上看到有人翻譯成信息覓食理論，是把人搜尋情報視為一種覓食行為，藉此研究使用者是怎麼從一個網頁轉移到到下一個網頁。</p>

<p>另外書中有提到理論生態學的東西，說明 <code>Information Foraging</code> 源自於生態學裡面的覓食理論，相關的有 Optimal foraging theory，</p>
]]></content>
  </entry>
  
</feed>
