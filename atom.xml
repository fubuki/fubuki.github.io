<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Learning Blog]]></title>
  <link href="http://fubuki.github.io/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2014-07-15T23:58:02+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Discourse Analysis]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/15/discourse-analysis/"/>
    <updated>2014-07-15T23:21:05+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/15/discourse-analysis</id>
    <content type="html"><![CDATA[<p>Discourse analysis : 在處理對話系統所建立的模型，用來分析句子跟句子之間的關係。<br/>
可參考<a href="http://en.wikipedia.org/wiki/Discourse_analysis">wiki</a>獲得更詳細的解釋。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自學機器學習的四種方法]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/14/zi-xue-ji-qi-xue-xi-de-si-zhong-fang-fa/"/>
    <updated>2014-07-14T23:51:59+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/14/zi-xue-ji-qi-xue-xi-de-si-zhong-fang-fa</id>
    <content type="html"><![CDATA[<p>4 Self-Study Machine Learning Projects <a href="http://machinelearningmastery.com/self-study-machine-learning-projects/">原文</a>  <a href="http://blog.jobbole.com/67621/">中文版</a></p>

<!-- more -->


<h2>心得</h2>

<p>這篇文章主要是提供初學者如何開始學習的方法，我覺得還蠻不錯，目前有些語言提供關於機器學習的函式庫，我這邊主要是用python的scikit-learn，因為可以直接搭配其他函式庫完成我想要的功能，雖然我也有使用R語言不過主要使用在統計跟產生圖表上，python這邊我可以直接搭配Scrapy和NLTK作出分析網路文章的功能。</p>

<p>另外文章有提到挑選一個數據集，然後選擇一種最適合的算法去處理他，目前有不少公開資料可以使用，之前在弄Mahout的時候我也有有找跟電影相關的資料可以使用，但是我比較偏向自然語言處理這部分，去分析這篇留言的評論是負面還是正面以及文章推薦系統，不過我想文章作者想要初學者找一個資料去分析主要是希望能夠了解各種資料都有他適合的算法，而要選擇適合的算法是我覺得最困難的地方，因為不同類型資料有不同的特性，如果不是在那方面有相關知識的人是比較難處理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新收集的書籍]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/13/xin-shou-ji-de-shu-ji/"/>
    <updated>2014-07-13T23:59:32+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/13/xin-shou-ji-de-shu-ji</id>
    <content type="html"><![CDATA[<ol>
<li>Monitoring with Ganglia</li>
<li>算法谜题</li>
<li>内存数据管理</li>
<li>编程原本</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL 日期經典問題]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/10/sql-ri-qi-jing-dian-wen-ti-sheng-ri-wen-ti/"/>
    <updated>2014-07-10T23:39:38+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/10/sql-ri-qi-jing-dian-wen-ti-sheng-ri-wen-ti</id>
    <content type="html"><![CDATA[<p>介紹關於使用MySQL處理日期的相關問題。<br/>
1. 生日問題 <br/>
2. 重疊問題 <br/>
3. 星期數問題</p>

<!-- more -->


<h2>生日問題</h2>

<h3>簡介</h3>

<p>查詢一個人最接近的生日日期，需要注意處理閏月的問題。</p>

<h2>重疊問題</h2>

<h3>簡介</h3>

<p>主要是時間重疊的問題。
1. 標示重疊
2. 分組重疊
3. 最大重疊會話術</p>

<h2>星期數問題</h2>

<h3>簡介</h3>

<p>判斷特定日期是星期幾，每周統計數量，計算工作日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的幾種類型樹]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/09/chang-yong-de-ji-zhong-lei-xing-shu/"/>
    <updated>2014-07-09T23:54:14+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/09/chang-yong-de-ji-zhong-lei-xing-shu</id>
    <content type="html"><![CDATA[<ol>
<li>B-tree</li>
<li>Red–black tree</li>
<li>AVL tree</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Restart Php Script by Register_shutdown_function and Pcntl_exec]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/07/register-shutdown-function-and-destructor/"/>
    <updated>2014-07-07T23:07:53+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/07/register-shutdown-function-and-destructor</id>
    <content type="html"><![CDATA[<p>在使用PHP CLI 跑背景程式有時候會因為記憶體溢出或是其他原因導致程式停止執行，需要讓程式自行重新啟動。</p>

<!-- more -->


<p>register_shutdown_function 是可以讓PHP在意外終止的時候可以去執行特定函式，配合 <code>pcntl_exec()</code> 便可以
完成當程式發生FatalError 時可以自動重新啟動。</p>

<script src="https://gist.github.com/fubuki/e621eb4844a975b9c0e1.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Memory Monitor Commands]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/04/linux-memory-monitor-commands/"/>
    <updated>2014-07-04T23:20:56+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/04/linux-memory-monitor-commands</id>
    <content type="html"><![CDATA[<p>記錄監控linux主機記憶體使用量的命令。</p>

<!-- more -->


<ol>
<li><code>free -m</code></li>
<li><code>ps aux --sort -rss</code></li>
<li><code>ps -ylC xxx --sort:rss | awk '{sum+=$8; ++n} END {print "Tot="sum"("n")";print "Avg="sum"/"n"="sum/n/1024"MB"}'</code></li>
<li><code>netstat -an | awk '/^tcp/ {++s[$NF]} END {for(a in s) print a, s[a]}'</code></li>
<li><code>top</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NFA 和 DFA]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/03/nfa-he-dfa/"/>
    <updated>2014-07-03T23:53:18+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/03/nfa-he-dfa</id>
    <content type="html"><![CDATA[<h2>何謂 NFA 和 DFA</h2>

<p>NFA(Nondeterministic Finite Automaton):從一個狀態到另一個狀態是不確定的。</p>

<p>DFA(Deterministic Finite Automaton):  可以檢查輸入字串是否符合這個狀態機。</p>

<p>ε遷移</p>

<h2>正規表現式 傳喚成 NFA 轉換成 DFA</h2>

<h2>NLP裡面的應用</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Php-fpm 優化參數]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/01/php-fpm-you-hua-can-shu/"/>
    <updated>2014-07-01T23:30:29+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/01/php-fpm-you-hua-can-shu</id>
    <content type="html"><![CDATA[<p>warning pool www child exited on signal 9 (sigkill) after seconds from start</p>

<!-- more -->


<p>php-fpm管理進程的模式有靜態和動態，差別在於靜態會根據參數直接生成固定的進程，動態則是會動態調整所需要的進程，
選擇哪個模式端看於硬體上記憶體大小的差別。</p>

<h2>靜態或是動態</h2>

<p>pm = static or dynamic</p>

<h2>靜態方法</h2>

<p>pm.max_children : php-fpm 最大進程數</p>

<h2>動態方法</h2>

<p>pm.start_servers : php-fpm 一開始創鍵的進程數</p>

<p>pm.min_spare_servers : php-fpm 最小的進程數</p>

<p>pm.max_spare_servers : php-fpm 最大進程數</p>

<h2>其他參數</h2>

<p>pm.max_requests : 一個進程處理多少個請求後就重新啟動</p>

<h2>參數大小設定規則</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[七月書單]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/30/qi-yue-shu-dan/"/>
    <updated>2014-06-30T21:13:05+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/30/qi-yue-shu-dan</id>
    <content type="html"><![CDATA[<p>記錄七月要看完的書單。</p>

<!-- more -->


<ol>
<li>自然語言處理綜論</li>
<li>统计自然语言处理基礎</li>
<li>信息檢索導論</li>
<li>Building.Polyfills</li>
<li>Data Push Apps with HTML5 SSE</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP 之 Fastcgi_finish_request]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/29/php-zhi-fastcgi-finish-request/"/>
    <updated>2014-06-29T23:02:40+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/29/php-zhi-fastcgi-finish-request</id>
    <content type="html"><![CDATA[<p>PHP 在 fast-cgi 模式下有一個有趣的函式 <code>fastcgi_finish_request</code> 可以使用，在<a href="http://php.net/manual/en/function.fastcgi-finish-request.php">function.fastcgi-finish-request</a>
有說明這個函式是讓開發者強制停止與客戶端之間的連線，但是服務端的腳本還是持續執行，這讓客戶端可以不用等待一些耗時的操作，
不過如果要達成類似的效果我還是比較喜歡用丟到隊列去執行的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcache 調整]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/28/memcache-diao-zheng/"/>
    <updated>2014-06-28T23:51:15+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/28/memcache-diao-zheng</id>
    <content type="html"><![CDATA[<p>memcached tips</p>

<!-- more -->


<h2>啟動參數</h2>

<h2>運行狀況</h2>

<h2>memcached集群</h2>

<h2>預熱</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML5 Polyfills]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/27/html5-polyfills/"/>
    <updated>2014-06-27T22:46:26+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/27/html5-polyfills</id>
    <content type="html"><![CDATA[<p><a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">What is a Polyfill?</a></p>

<blockquote><p>A polyfill, or polyfiller, is a piece of code (or plug-in) that provides the technology that<br/>
you, the developer, expect the browser to provide natively. Flattening the API landscape
if you will.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 和 iOS在使用推播的不同處]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/25/android-he-ioszai-shi-yong-tui-bo-de-bu-tong-chu/"/>
    <updated>2014-06-25T23:05:45+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/25/android-he-ioszai-shi-yong-tui-bo-de-bu-tong-chu</id>
    <content type="html"><![CDATA[<p>記錄在使用推播時 Android 和 iOS 兩者不同之處。<br/>
<a href="http://blog.katty.in/4300">iOSとAndroidのプッシュ通知の開発の違いまとめ</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcached With Namespace]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/24/memcached-with-namespace/"/>
    <updated>2014-06-24T21:23:07+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/24/memcached-with-namespace</id>
    <content type="html"><![CDATA[<p>memcached如何實作namespace的方法。</p>

<!-- more -->


<p>memcached沒有支援namespace所以沒辦法直接批量刪除鍵值，原本是可以直接拉出在memcached裡面的key然後只
刪除想要刪除的鍵值，但是從取出所有key會很耗費資源所以不會考慮，之後有想過在DataBase的地方存放所有
key然後就可以快速查詢想要批量刪除的鍵值，最後是使用Deleting by Namespace的方法，實作出namespace後
透過namespace批量刪除，實作可以參考<a href="https://code.google.com/p/memcached/wiki/NewProgrammingTricks#Namespacing">NewProgrammingTricks</a>，其實他的主要想法是使用固定的key pattern
實作namespace，在透過管理namespace的版本號讓舊的cache自然失效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 和 HDF5]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/22/python-he-hdf5/"/>
    <updated>2014-06-22T23:41:59+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/22/python-he-hdf5</id>
    <content type="html"><![CDATA[<p>HDF5檔案格式: <a href="http://www.hdfgroup.org/HDF5/">HDF5</a><br/>
HDFS FOR Python : <a href="http://www.hdfgroup.org/HDF5/">HDF5</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL災難恢复]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/22/mysql-zai-nan-hui-fu/"/>
    <updated>2014-06-22T23:30:34+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/22/mysql-zai-nan-hui-fu</id>
    <content type="html"><![CDATA[<p>MySQL 如何備份和恢復</p>

<!-- more -->



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL 鎖的機制]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/21/mysql-suo-de-ji-zhi/"/>
    <updated>2014-06-21T22:37:52+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/21/mysql-suo-de-ji-zhi</id>
    <content type="html"><![CDATA[<p>記錄並分析各種鎖。</p>

<!-- more -->


<h2>lock 和 latch</h2>

<h2>鎖的種類</h2>

<h2>鎖有可能造成的問題</h2>

<h2>阻塞的問題</h2>

<h2>dead lock</h2>

<h2>Lock Escalation</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx Upstream 反向代理的機制]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/19/nginx-upstream-fan-xiang-dai-de-ji-zhi/"/>
    <updated>2014-06-19T22:21:25+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/19/nginx-upstream-fan-xiang-dai-de-ji-zhi</id>
    <content type="html"><![CDATA[<p>如何設定nginx 反向代理的功能。</p>

<!-- more -->


<h2>upstream 建立流程與機制</h2>

<ol>
<li>啟動upstream</li>
<li>與上游伺服器建立連結</li>
<li>發送請求給上游伺服器</li>
<li>接收上游伺服器的響應頭部</li>
<li>轉發跟不轉發響應</li>
<li>結束upstream的請求</li>
</ol>


<h2>與upstream相關的原始碼</h2>

<ol>
<li>ngx_http_upstream_init</li>
<li>ngx_http_upstream_init_request</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcached 1MB Limit]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/18/memcached-1mb-limit/"/>
    <updated>2014-06-18T23:06:14+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/18/memcached-1mb-limit</id>
    <content type="html"><![CDATA[<p>memcached在儲存單筆記錄的時候會有個限制，每筆記錄只能存放最大1MB的大小，以前沒有遇過這種問題，但是在最近一個
專案上面突然遇到快取沒有作用的問題，後來發現有可能是存放的資料大於1MB的問題，在<a href="http://docs.oracle.com/cd/E17952_01/refman-5.6-en/ha-memcached-faq.html">ha-memcached-faq</a>裡面有說為什麼
預設1MB和如何調整大小。</p>
]]></content>
  </entry>
  
</feed>
