<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Learning Blog]]></title>
  <link href="http://fubuki.github.io/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2014-12-30T23:13:15+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Yum 出現 Cannot Retrieve Metalink for Repository: Epel 的錯誤]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/30/cannot-retrieve-metalink-for-repository-epel/"/>
    <updated>2014-12-30T22:49:21+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/30/cannot-retrieve-metalink-for-repository-epel</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在 Centos 6 上面更新套件的時候出現了 <code>Cannot retrieve metalink for repository: epel</code> 的錯誤，
命令列是寫說是因為 SSL 連線出問題，後來從網路上看到是要更新 <a href="http://en.wikipedia.org/wiki/Network_Security_Services">nss</a> 這個套件。</p>

<p><a href="http://en.wikipedia.org/wiki/Network_Security_Services">nss</a> 全名是 <code>Network Security Services</code> 似乎是負責網路加密傳送的功能，不知道是版本的關係才會出現
 SSL 問題，在網路上也到有一些加密的問題也是出自於 <a href="http://en.wikipedia.org/wiki/Network_Security_Services">nss</a>，而在 MDN 也有一篇 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Overview">Overview of NSS</a> 的文章，
 裡面也說明 nss 是一個開源的加密函式庫，而 Yum 有使用到 nss 處理 SSL 加密連線。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysqldump 備份資料庫指令]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/29/mysqldump/"/>
    <updated>2014-12-29T21:26:15+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/29/mysqldump</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近幫別人整理資料庫發現資料表的結構設計不當導致資料過多的時候效率變很差，原本更改資料表的結構
但是由於手上沒有 root 權限的帳號，資料庫也不能停機開啟 <code>safe mode</code>，所以只能先刪除資料。</p>

<p>目前 MySQL 資料庫最常用 <a href="http://dev.mysql.com/doc/refman/5.1/en/mysqldump.html">mysqldump</a> 備份，在 MySQL 官網有詳細的解說裡面有很多選項可以使用，但是
目前最常用到的選項是 <code>-single-transaction</code> 和 <code>-lock-all-tables</code>，<code>-single-transaction</code> 是在備份
資料前開啟交易，讓資料能夠盡量完整匯出，而 <code>-lock-all-tables</code> 則是給 MyISAM 這類不支援 transaction
 的資料表所用，他會在備份時 Lock Table 為 READ LOCAL 狀態，只允許 <a href="http://dev.mysql.com/doc/refman/5.0/en/concurrent-inserts.html">Concurrent Inserts</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker 的 Volumes 功能]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/28/docker-volumes/"/>
    <updated>2014-12-28T22:51:26+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/28/docker-volumes</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近在用 Docker 建立的 FFmpeg 的容器時，想要建立的直接在容器裡面寫入檔案執行轉檔，然後看到了 Docker 有類似掛載的功能，
可以建立 Volumes 讓各個不同的容器共用，之後如果有升級或是跟其他容器結合形成一個服務平台可以採取這樣的做法。</p>

<p>另外有看到一篇蠻有趣的文章 : <a href="http://stackoverflow.com/questions/18496940/how-to-deal-with-persistent-storage-e-g-databases-in-docker">How to deal with persistent storage (e.g. databases) in docker</a>，裡面的回答有提到一個東西
 <code>data only container</code>，似乎是建立一個專門掛載 Volumes 的 container ，從這篇 <a href="http://www.offermann.us/2013/12/tiny-docker-pieces-loosely-joined.html">Tiny Docker Pieces, Loosely Joined</a> 最後面
 有提到一些關於這樣做法的好處，似乎是能更好管理 Volumes 裡面的內容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[USRP + Rtl2832u 接收無線電]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/27/usrp-rtl2832u/"/>
    <updated>2014-12-27T22:25:49+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/27/usrp-rtl2832u</id>
    <content type="html"><![CDATA[<!-- more -->


<p>之前有看到一篇關於 火人節跟 <a href="http://openbts.blogspot.tw/">OpenBTS</a> 的文章，看到其中使用開源軟硬體建立一個通信平台讓我
很想玩玩看，理面比較重要的是 <code>USRP</code> 這部分的硬體，所以先從 <code>USRP</code> 這部分開始著手。</p>

<p>目前從網路上來看直接買硬體不太便宜但是有使用電視棒的替代入門方案，電視棒裡面的 rtl2832u 晶片
可以用來接收無線電的訊號，利用這個特性將訊號接入 PC 然後使用軟體解調訊號，剛好手上有個沒人
使用的電視棒， 就參考這篇 <a href="http://wiki.spench.net/wiki/USRP_Interfaces#Installer">教學</a> 架設平台，過程中最重要的更換電視棒的驅動程式這樣 SRP 的軟體才
抓得到電視棒，我是透過 HDSDR 處理電波訊號。</p>

<p>最後雖然架起來了但是似乎抓不到無線電訊號，我連 FM 也抓不到只有抓到一些雜訊，看起來是天線太爛了，
也有可能是電視本身的問題，之後在露天找一下相關的商品測試。</p>

<h4>安裝過程</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Kernel 安裝 Aufs]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/26/kernel-aufs/"/>
    <updated>2014-12-26T23:18:05+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/26/kernel-aufs</id>
    <content type="html"><![CDATA[<!-- more -->


<p>之前研究 Docker 了解了有一個 aufs 檔案系統，所以就想安裝來玩玩看。</p>

<h4>概要</h4>

<p>我是用手上的 Centos 6 測試的，安裝前要先下載下面幾個檔案，然後使用 <code>aufs3-standalone</code> 給
aufs3-linux 打上補丁然後在 config 時打開 aufs 的選項後編譯核心即可。</p>

<ol>
<li>aufs3-linux</li>
<li>aufs3-standalone</li>
<li>aufs-util git://git.code.sf.net/p/aufs/aufs-util</li>
</ol>


<h4>下載</h4>

<pre><code>git clone git://github.com/sfjro/aufs3-linux.git
git clone git://git.code.sf.net/p/aufs/aufs-util
cd aufs3-linux
git clone git://git.code.sf.net/p/aufs/aufs3-standalone
</code></pre>

<h4>切換版本</h4>

<p>切換 <code>aufs3-linux</code> 和 <code>aufs3-standalone</code> 的版本，目前支援到最新的 3.18 版本，
但是要注意兩個版本要一致。</p>

<h4>打上補丁</h4>

<pre><code>aufs3-standalone/aufs3-kbuild.patch
aufs3-standalone/aufs3-base.patch
aufs3-standalone/aufs3-mmap.patch
aufs3-standalone/aufs3-standalone.patch
</code></pre>

<h4>從aufs3-standalone 複製必要的檔案到 kernel</h4>

<pre><code>{Documentation,fs}
include/linux/aufs_type.h 
include/uapi/linux/aufs_type.h
</code></pre>

<h4>最後</h4>

<p>打開 aufs 的編譯選項，然後編譯核心重開機後還需要安裝 <code>aufs-util</code>，這樣 aufs 才能正常運作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Centos 6 升級核心到 3.18]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/25/centos-6-upgrade-to-3-dot-18/"/>
    <updated>2014-12-25T01:21:48+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/25/centos-6-upgrade-to-3-dot-18</id>
    <content type="html"><![CDATA[<!-- more -->


<p>今天把手上的 Centos 的核心從 2.6 升級到 3.18，順便紀錄一下升級的過程。</p>

<p>先下載新版的 Linux Kernel 檔案並且解壓縮。</p>

<pre><code>wget  https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.1.tar.gz
tar zxf linux-3.18.1.tar.gz
</code></pre>

<p>設定編譯選項，我原本找不到舊的編譯檔案，後來在 <code>/usr/src/kernel</code> 底下找到。</p>

<pre><code>cp /usr/src/kernel/config .config
make menuconfig
</code></pre>

<p>開始編譯核心和模組，加上 -j 參數使用多核心編譯。</p>

<pre><code>make -j bzImage 
make -j modules 
make -j modules_install 
</code></pre>

<p>安裝並且修正開機順序後重開機。</p>

<pre><code>make install
vim /etc/grub.conf
reboot
</code></pre>

<p>重開機後就可以看到核心已經變成 3.18 版本，不過卻出現另外一個問題，當我要使用 <code>docker</code>
的時候卻出現 iptables 的錯誤，最後發現是編譯的時候沒有將 NAT 的模組編譯進去所導致的問題，
之後重新編譯就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kibana 資料可視化項目]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/24/kibana/"/>
    <updated>2014-12-24T22:57:33+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/24/kibana</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/elasticsearch/kibana">kibana</a> 是基於 ElasticSearch 建立的資料可視化項目</p>

<!-- more -->


<p>之前有使用 ElasticSearch 建立資料庫的搜尋服務，其中也有透過 logstash 收集伺服器上面的 LOG 檔案傳給 ElasticSearch
進行處理然後透過 API 呼叫取得處理過的資料顯示在後台上。</p>

<p>LOG檔的訊息通常大量並且雜亂的，而且都帶有時間標記，所以為了讓人使用這些大量的資料就必須要有個可以分析並且顯示的後台，
所以看到網路上有出一個 <a href="https://github.com/elasticsearch/kibana">kibana</a> 的資料可視化項目，</p>

<p><a href="https://github.com/elasticsearch/kibana">kibana</a> 安裝很簡單，比較麻煩的反而是將 LOG 檔透過 logstash 丟到 ElasticSearch 中處理，之後的步驟可以參考這個 <a href="http://kibana.logstash.es/">教程</a>
，建立所需要的環境之後便可以開始分析機器上面的 LOG 檔案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker 的 Storage Driver]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/23/docker-storage/"/>
    <updated>2014-12-23T21:46:07+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/23/docker-storage</id>
    <content type="html"><![CDATA[<p>最近似乎是因為 docker 的 Storage Driver 關係導致 Kernel Bug 所以要研究一下這一個部分。</p>

<!-- more -->


<p>如果在命令列下 <code>docker -D info</code> 其中就可以看到目前機器上的 Storage Driver 是什麼，目前我手上兩種 Linux 發行版，
在 ubuntu 14.04LTS 下可以看是 <code>aufs</code>，如果是在 centos 6 會是 <code>device-mapper</code>，另外 docker 還有支援 Btrfs。</p>

<h4>　Aufs</h4>

<p>目前只有在 Debain 系列的 Linux 版本才有包進內核裡的檔案系統，開發者是名叫<code>岡島順治郎</code>的日本人，從網路上的評價
來看 Aufs 似乎是個蠻不錯的檔案系統，但是由於一些原因一直不能加進 Linux 的內核裡面，原因似乎是代碼寫的不太好的原因。</p>

<p>官網在這 <a href="http://aufs.sourceforge.net/">Aufs</a> 另有一些可以研究的東西 <code>Union mount</code> 和 <code>UnionFS</code>.</p>

<h4>Device-mapper</h4>

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html">Linux 内核中的 Device Mapper 機制</a></p>

<h4>Btrfs</h4>

<p>Oracle 開發的檔案系統，從 2007 年開始開發，已經有穩定版可以使用，目前 facebook 有在測試這個檔案系統。</p>

<p>wiki : <a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">btrfs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分析 Vmcore 和 vmcore-dmesg.txt]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/22/vmcore-dmesg-dot-txt/"/>
    <updated>2014-12-22T23:11:07+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/22/vmcore-dmesg-dot-txt</id>
    <content type="html"><![CDATA[<!-- more -->


<p>今天在試玩 docker 的時候，因為不知名因素導致系統直接重啟，後來發現是整個內核 crash 原因是似乎是跟 <code>device-mapper</code> 脫不了關係，
看他 console 列出的最後訊息可以得知在 <code>/var/crash</code> 生成了兩個文件: <code>vmcore</code> 和 <code>vmcore-dmesg.txt</code>。</p>

<p>在 <code>/var/crash</code> 下面的兩個文件是記錄了系統 Crash 時的最後訊息，可以透過這些文件追蹤發生了什麼事，要追蹤需要使用幾個工具: kdump 和 crash
，kdump 是讓系統 Crash 時將內核的訊息 dump 到硬碟上以供使用者除錯， crash 是可以去分析 <code>vmcore</code> 的內容，但是需要 vmlinux 的檔案才能分析
 vmcore 的內容， vmlinux 需要跟目前的系統核心相同。</p>

<p> 另外一個 vmcore-dmesg.txt 檔案是記錄一些系統資訊和 Crash 時的資訊，雖然沒有比 vmcore 詳細但是也可以作為參考，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Openresty Server]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/21/ngx-openresty/"/>
    <updated>2014-12-21T22:59:33+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/21/ngx-openresty</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="http://openresty.org/">openresty</a> 為核心是 nginx 在外加一些第三方模組的版本。</p>

<p>之前在研究 nginx 跟 Lua 結合的資訊時看到了一篇 <a href="http://agentzh.org/misc/slides/ngx-openresty-ecosystem/#1">ngx_openresty: an Nginx ecosystem glued by Lua</a>，
裡面介紹了 <a href="https://github.com/openresty/ngx_openresty">ngx-openresty</a> ，並且介紹了這個基於 nginx 擴展版本裡面有哪些功能，並且從文章標題就可以
得知裡面使用 Lua 整合整個生態系統。</p>

<p><a href="http://openresty.org/">openresty</a> 從官網看到可以透過編寫 Lua 腳本跟 mysql,redis 連線做出反向代理的功能，另外也有看到有人
使用 Lua 編寫影音加密的 Http LiveStream 的功能，看起來可以考慮將一些應用層的東西轉移到 ngix 上面藉此提高
網站的效率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Docker 建立 FFmpeg 環境]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/20/docker-ffmpeg/"/>
    <updated>2014-12-20T22:33:21+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/20/docker-ffmpeg</id>
    <content type="html"><![CDATA[<!-- more -->


<p> 之前在安裝 FFmpeg 的時候吃了不少苦頭，然後未來也有可能會需要更新一些已經有安裝的 Server，所以嘗試一下使用 docker 建立
  ffmpeg 環境，目前有找到 <a href="https://registry.hub.docker.com/u/cellofellow/ffmpeg/">cellofellow/ffmpeg</a> 這個 docker file 可以使用， docker file 安裝指令如下:</p>

<pre><code>docker pull cellofellow/ffmpeg  
docker run -i -t cellofellow/ffmpeg /bin/bash
</code></pre>

<p>安裝後進去就可以使用最新版的 ffmpeg 下面是他的編譯參數目前手上會用的編碼都有包進去了，比較有問題的是 <code>libfdk-aac</code> 與
 <code>libfaac</code> 的差別，兩個似乎都是用來解 FAAC 的，不過從網路上的資訊來看是 libfdk-aac 比較好。</p>

<pre><code>configuration: 
--extra-libs=-ldl 
--enable-gpl 
--enable-libass 
--enable-libfdk-aac 
--enable-libmp3lame 
--enable-libopus 
--enable-libtheora 
--enable-libvorbis 
--enable-libvpx 
--enable-libx264 
--enable-libx265 
--enable-nonfree
</code></pre>

<p>題外話在網路上有看到 Cookpad 也有用 docker 建立影音轉碼平台 : <a href="http://techlife.cookpad.com/entry/ffmpeg_and_imagemagick_setup_with_docker">Dockerでffmpegもimagemagickも怖くないという話</a>，
裡面的的 docker file 也有放出來 <a href="https://github.com/cookpad/janiConverter">janiConverter</a> 讓人使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[添加 Flv Keyframes 支持拖動撥放]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/19/nginx-yamdi-flvtool/"/>
    <updated>2014-12-19T22:36:50+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/19/nginx-yamdi-flvtool</id>
    <content type="html"><![CDATA[<!-- more -->


<p>目前在研究在多種裝置上面支援播放影片，目前看到有使用下面幾種方式:</p>

<ol>
<li>RTMP/RTMPT</li>
<li>RTSP</li>
<li>HTTP</li>
<li>MMS</li>
<li>HLS</li>
</ol>


<p>而手上有 mp4 和 flv 以及 m3u8 三種格式需要播放，目前是先選用 nginx 透過 HTTP 播放這樣需要安裝的套件比較少，
如果要使用 CDN 擴展也比較方便，但是除了原本的 m3u8 格式可以支援拖動撥放，另外兩個要使用其他工具添加 keyframes 才能讓
播放器不需要載入全部檔案就可以撥放，下面記錄目前有使用哪些工具添加 keyframes。</p>

<h3>flv</h3>

<ol>
<li><a href="http://yamdi.sourceforge.net/">yamdi</a></li>
<li><a href="https://github.com/Elbandi/flvtool-pp">flvtool++</a></li>
</ol>


<h3>mp4</h3>

<ol>
<li><a href="https://github.com/danielgtaylor/qtfaststart">qtfaststart</a></li>
<li>MP4Box</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Centos 6 安裝 Ffmpeg Flvtool++ Qtfaststart]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/18/ffmpeg-flvtool-plus-plus-qtfaststart/"/>
    <updated>2014-12-18T22:43:14+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/18/ffmpeg-flvtool-plus-plus-qtfaststart</id>
    <content type="html"><![CDATA[<!-- more -->


<h4>ffmpeg</h4>

<p>在 Centos 上面使用 yum 安裝的 ffmpeg 版本都太舊了，版本只有到 0.6 而已目前最新已經到 2.5 了，
另外使用 yum 安裝的 ffmpeg 似乎沒有把一些我需要的編碼加進去導致沒有支援 flv 的轉碼。</p>

<p>目前看到網路上有很多教程解說如何從原始碼安裝 ffmpeg ，但是在編譯的時候在跑 x264 的時候就沒有辦法通過編譯
，最後參考這篇 <a href="http://wiki.razuna.com/display/ecp/FFMpeg+Installation+on+CentOS+and+RedHat">Install FFMpeg</a> 才能編譯過去。看起來也許是之前的函式庫沒有移除乾淨所導致的。</p>

<p>下面兩個是讓 mp4 和 flv 檔案可以透過 http 的方式拖動撥放</p>

<h4>qtfaststart</h4>

<p><a href="https://github.com/danielgtaylor/qtfaststart">qtfaststart</a> 是用來轉 mp4 的相關工具，直接透過 pypi 安裝即可。</p>

<pre><code>easy_install qtfaststart
</code></pre>

<h4>flvtool++</h4>

<p>網路上有 <a href="https://github.com/Elbandi/flvtool-pp">flvtool++</a> 和 flvtool2 這兩者似乎是類似的東西用來處理 flv 檔案， yum 源裡面是有 flvtool2
<a href="https://github.com/Elbandi/flvtool-pp">flvtool++</a> 只能自行編譯安裝。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx 添加 Lua 的模組]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/17/nginx-lua/"/>
    <updated>2014-12-17T00:25:04+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/17/nginx-lua</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Nginx 可以藉由安裝 <a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module</a> 支持 Lua，但是要安裝模組就必須從原始碼開始編譯，這邊就記錄一下
在 Centos 上面的安裝過程。</p>

<h3>下載 nginx 的原始碼</h3>

<pre><code>wget http://nginx.org/download/nginx-1.7.7.tar.gz
tar zxf nginx-1.7.7.tar.gz
</code></pre>

<h3>下載相關模組</h3>

<ol>
<li><a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module</a> 支援 Lua 的模組</li>
<li><a href="https://github.com/simpl/ngx_devel_kit">ngx_devel_kit</a> Nginx 的開發工具有些模組需要這個套件</li>
<li><a href="http://luajit.org/">LuaJIT</a> Lua 的模組需要它編譯出來的 library</li>
<li><a href="https://github.com/openresty/set-misc-nginx-module">set-misc-nginx-module</a> 增加 nginx 支援的語法，順便編譯進去增強 nginx 的功能</li>
</ol>


<h3>編譯參數</h3>

<pre><code>./configure --prefix=/opt/nginx \
     --add-module=/root/ngx_devel_kit \
     --add-module=/root/lua-nginx-module \
     --add-module=/root/set-misc-nginx-module 

make &amp;&amp; make install
</code></pre>

<h3>設定成服務</h3>

<pre><code>ln -s /opt/nginx/sbin/nginx /usr/sbin/nginx

vim /etc/init.d/nginx
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aeron Message Protocol]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/16/aeron-message-protocol/"/>
    <updated>2014-12-16T23:24:50+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/16/aeron-message-protocol</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近發現了一個跟消息系統有關的的開源專案: <a href="https://github.com/real-logic/Aeron">Aeron</a> ，目前已經手上是用過好幾種消息系統每種都有他們的特性，
所以是否還需要另外新的消息系統? 這篇 <a href="http://highscalability.com/blog/2014/11/17/aeron-do-we-really-need-another-messaging-system.html">Aeron: Do we really need another messaging system?</a> 可以讀讀，了解
跟為何開發這個系統。</p>

<p>上面的文章有提到其他消息系統像是瑞士刀， <a href="https://github.com/real-logic/Aeron">Aeron</a> 則像是一把手術刀，沒有提供太多功能，並且是放在 tcp 的層級使用，
看起來是用來建立系統低階的部分高階的部分在讓開發者另外去解決，這讓我感覺有點像 zeroMQ 但是文章裡面卻說是不一樣的東西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Apache 安裝上 Wsgi 執行 Django]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/15/apache-wsgi-python/"/>
    <updated>2014-12-15T21:57:18+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/15/apache-wsgi-python</id>
    <content type="html"><![CDATA[<!-- more -->


<p>apache 上面可以藉由安裝 mod_wsgi 執行 python 的程式碼，這邊記錄一下在 Centos 上面的安裝過程。</p>

<p>Apache 和 python 一開始就安裝在機器上面了，然後 django 和 web.py 則是透過 <code>pip</code> 或是 <code>easy_install</code> 安裝,以為很簡單卻卡在安裝 mod_wsgi 上面。</p>

<p>原本是透過 <a href="https://code.google.com/p/modwsgi/">mod_wsgi</a> 的原始碼編譯，但是出現下面的錯誤:</p>

<pre><code>apxs:Error: Command failed with rc=65536
</code></pre>

<p>原因在官網的 <a href="https://code.google.com/p/modwsgi/wiki/InstallationIssues">Installation Issues</a> 有提到是因為 python 和 apache 的版本不合，一個為 32 位元一個為 64 位元就會
出現這種錯誤，只能重新編譯。</p>

<p>後來試著用 <code>yum install mod_wsgi</code> 成功安裝但是在 apache 的 error log 出現 <code>ImportError: No module named web</code> ，
在 web.py 的官網建議加入檔案路徑加入環境變數，不過還是失敗。</p>

<p>最後發現是 python 版本的問題，機器上面安裝兩種 python 的版本 2.6 和 2.7， yum 透過 2.6 編譯 mod_wsgi 與程式使用的
 2.7 不同而導致這個問題，最後下載 python 原始碼重新編譯才行。</p>

<p> 下載 python 的原始碼並且在 configure 加上 &ndash;enable-shared 編譯安裝，安裝後執行 python 遇到下面的錯誤，找不到 lib 的路徑。</p>

<pre><code>python: error while loading shared libraries: libpython2.7.so.1.0: cannot open shared object file: No such file or directory
</code></pre>

<p>使用 ldconfig 指定 lib 位置後重新編譯安裝 mode_wsgi 就建立好環境了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Io.js]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/14/io-dot-js/"/>
    <updated>2014-12-14T22:29:30+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/14/io-dot-js</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近看到一個消息，出了一個 node.js 的分支 <a href="http://iojs.org/">Io.js</a>，是由原本開發的 node.js 的核心成員另外跳出來的作的，
原因是不滿 <a href="https://www.joyent.com/technology/nodejs">joyent</a> 的管理風格。</p>

<p>目前 node.js 的走向偏向將目前的版本穩定，但是這些核心成員更希望能夠聽取社區的聲音增加新的功能而成立了
<a href="http://nodeforward.org/">nodeforward</a> 然後過不久後就放出 <a href="http://iojs.org/">Io.js</a>，在這邊 <a href="http://blog.izs.me/post/104685388058/io-js">What is io.js?</a> 有寫出他們跳出來做的目的跟未來的方向。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[管理 Linux 啟動執行的服務]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/13/linux-start-service/"/>
    <updated>2014-12-13T23:09:26+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/13/linux-start-service</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在 Liinux 使用 <code>update--rc.d</code> 或是 <code>chkconfig</code> 管理開機時要啟動哪些服務，兩者用法是類似的，
另外還有 Ubuntu 底下也有 <code>rcconf</code> 和 <code>sysv-rc-conf</code> 可以使用，不過上面的指令會提到關於執行 level 的概念
決定服務要在哪個時候執行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lighttpd 搭配 Fastcgi 和 Webpy]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/12/lighttpd-fastcgi-web-dot-py/"/>
    <updated>2014-12-12T00:18:20+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/12/lighttpd-fastcgi-web-dot-py</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近在研究別人寫的專案看到使用 Lighttpd 跑 Python 的程式碼，透過 Fastcgi 跟 Python 程式碼溝通，
Python 端則是使用 <a href="http://webpy.org">Webpy</a>，環境可以參考 <a href="http://webpy.org/cookbook/fastcgi-lighttpd">Webpy + LightTTPD with FastCGi</a>。</p>

<pre><code>apt-get install lighttpd
vim /etc/lighttpd/lighttpd.conf

fastcgi.server = ( "/app.py" =&gt;
(( "socket" =&gt; "/tmp/fastcgi.socket",
    "bin-path" =&gt; "/var/www/html/app.py",
    "max-procs" =&gt; 1,
    "bin-environment" =&gt; (
    "REAL_SCRIPT_NAME" =&gt; ""
    ),
    "check-local" =&gt; "disable"
))
)

easy_install web.py
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分散式檔案系統]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/11/distributed-filesystem/"/>
    <updated>2014-12-11T22:50:42+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/11/distributed-filesystem</id>
    <content type="html"><![CDATA[<p>紀錄一下目前有看過哪些分散式檔案系統。</p>

<!-- more -->


<p>在以前 Google 內部使用自行開發的 GFS 作為檔案系統，並且將相關論文開放給外界參考後生出了 hadoop 之類的軟體，
而現在有不少生產環境使用了分散式檔案系統，</p>

<ol>
<li>HDFS</li>
<li>LeoFS</li>
<li>MogileFS</li>
<li>ZFS</li>
<li>FastDFS</li>
<li>GlusterFS</li>
<li>GridFS</li>
<li>TFS</li>
</ol>


<h3>HDFS</h3>

<p>hadoop 所使用的檔案系統。</p>

<h3>LeoFS</h3>

<p>以前同事待的公司使用 DFS 系統。</p>

<h3>MogileFS</h3>

<p>KKBOX 內部使用 MogileFS 存放音樂資料。</p>

<h3>ZFS</h3>

<p>由 SUN 所開發檔案系統，一開始是在 Solaris 才有的後來有人移植到各種作業系統上。</p>

<h3>FastDFS</h3>

<h3>GlusterFS</h3>

<p>目前似乎由 Red Hat 維護。</p>

<h3>GridFS</h3>

<p>MongoDB  使用的一種檔案系統。</p>

<h3>TFS</h3>

<p>淘寶開發的檔案系統。</p>
]]></content>
  </entry>
  
</feed>
