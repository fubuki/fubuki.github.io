<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Learning Blog]]></title>
  <link href="http://fubuki.github.io/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2014-11-13T23:21:15+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kanban管理]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/13/kanbanguan-li/"/>
    <updated>2014-11-13T21:46:32+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/13/kanbanguan-li</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>什麼是 Kanban</h3>

<p>之前有使用 <a href="https://trello.com">Trello</a> 後來可以查到了 Kanban 這個專案管理方式，Kanban 管理源自豐田生產系統，重點在於 JIT 這個 Pull 管理概念，
為了讓整個專案流程能夠順暢進行。</p>

<h3>看板種類</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何安裝 Snort]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/12/snort-install/"/>
    <updated>2014-11-12T21:26:49+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/12/snort-install</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://www.snort.org/">snort</a> 是一個入侵偵測系統，在網路上有一些現成的規則檔載入到 snort，也可以自行撰寫需要的規則。</p>

<h3>下載 snort 和 daq。</h3>

<pre><code>wget https://www.snort.org/downloads/snort/daq-2.0.4.tar.gz
wget https://www.snort.org/downloads/snort/snort-2.9.7.0.tar.gz
</code></pre>

<h3>安裝 libdnet</h3>

<p>在 ubuntu 底下安裝時會發現需要比較新的 <a href="https://code.google.com/p/libdnet/">libdnet</a> 版本，使用 <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-checkinstall/">checkinstall</a> 建立 deb 檔後安裝。</p>

<h3>安裝 daq 和 snort</h3>

<h3>下載官方 RULE</h3>

<pre><code>wget https://www.snort.org/rules/community
tar -xvfz community.tar.gz -C /etc/snort/rules
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[P2P NAT 穿越技術]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/11/p2p-nat/"/>
    <updated>2014-11-11T23:09:17+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/11/p2p-nat</id>
    <content type="html"><![CDATA[<p>P2P 在 NAT 環境的穿越技術。</p>

<!-- more -->


<h3>NAT 有哪些類型</h3>

<ol>
<li>Full Cone NAT</li>
<li>Restricted Cone NAT</li>
<li>Port Restricted Cone NAT</li>
<li>Symmetric NAT</li>
</ol>


<h3>NAT 穿越技術</h3>

<ol>
<li>ALG</li>
<li>MIDCOM</li>
<li>STUN</li>
<li>TURN</li>
<li>FullProxy</li>
<li>ICE</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP One-Time Passwords]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/10/php-one-time-passwords/"/>
    <updated>2014-11-10T22:02:49+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/10/php-one-time-passwords</id>
    <content type="html"><![CDATA[<p>使用 PHP 實現 One-Time Passwords (OTP) 。</p>

<!-- more -->


<h3>什麼是 OTP</h3>

<p>OTP 簡單說是每次使用帳密登入都是使用密碼產生器產生一次性密碼，這樣比起傳統的密碼安全許多，
但是需要額外裝置建構這個系統，目前似乎有人使用 email 和 sms 驗證。</p>

<h3>RFC 文件</h3>

<ol>
<li><a href="http://tools.ietf.org/html/rfc2289">RFC 2289</a></li>
<li><a href="http://tools.ietf.org/html/rfc1760">RFC 1760</a></li>
<li><a href="http://tools.ietf.org/html/rfc4226">RFC 4226</a></li>
<li><a href="http://tools.ietf.org/html/rfc6238">RFC 6238</a></li>
</ol>


<h3>相關專案</h3>

<ol>
<li><a href="http://sourceforge.net/projects/php-otp/">PHP One-Time Passwords</a></li>
<li><a href="https://github.com/rbakels/oath-php">oath-php</a></li>
<li><a href="http://motp.sourceforge.net/">Mobile-OTP</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP: Thread-Safe Resource Manager]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/09/php-thread-safe-resource-manager/"/>
    <updated>2014-11-09T21:18:29+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/09/php-thread-safe-resource-manager</id>
    <content type="html"><![CDATA[<p>PHP 的執行緒安全資源管理機制。</p>

<!-- more -->


<p><a href="http://blog.codinglabs.org/articles/zend-thread-safety.html">PHP中的线程安全</a>
<a href="http://www.54chen.com/php-tech/what-is-tsrmls_cc.html">究竟什么是TSRMLS_CC？</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Erlang : Open Telecom Platform]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/08/erlang-open-telecom-platform/"/>
    <updated>2014-11-08T17:24:15+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/08/erlang-open-telecom-platform</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>open telecom platform  (OTP)  是什麼</h3>

<p>用來開發 erlang 的應用程式的一個平台，可以讓開發者建立一個用來開發分布式、高可用的應用程式。</p>

<h3>OTP 包含哪些項目</h3>

<ol>
<li>erlang 的直譯器</li>
<li>erlang 的編譯器</li>
<li>通訊協定</li>
<li><a href="http://en.wikipedia.org/wiki/Object_Request_Broker">Corba Object Request Broker</a></li>
<li>static analysis tool called Dialyzer</li>
<li><a href="http://en.wikipedia.org/wiki/Mnesia">Mnesia</a> 一個資料庫</li>
<li>一些函式庫</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Guard Clause and Nested Structure]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/07/guard-clause-and-nested-structure/"/>
    <updated>2014-11-07T08:18:53+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/07/guard-clause-and-nested-structure</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在一個函數裡面通常會有多個 if else 的條件子句，這時會有下面兩種寫法。</p>

<h3>Guard Clause</h3>

<p>Guard 有著防禦的意思，是在條件子句中直接離開函數，每個條件子句都是同一個階層。</p>

<pre><code>if (xxx) {
    return;
}

if (yyy) {
    return 
}

return;
</code></pre>

<h3>Nested Structure</h3>

<p>在一個條件子句中還有多層的條件子句，因此會看到下面這種情形，導致之後別人維護會很難看懂整個程式的。</p>

<pre><code>if (x == 1) {
    // do something
    if(y == 3) {
        // do something
        if(x == 4) {
            // do something
        } else {

        }
    } else {

    }
}
</code></pre>

<h3>感想</h3>

<p>大部分時候我都是用 Guard Clause 的寫法，我覺得盡量減少 <code>if else</code> 的層級看起來比較好懂也比較容易給之後的人維護修改，可以很容易看
出每個條件子句的用途為何。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP 使用 PDO 與 Mysql 進行持久化連接]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/06/pdo-mysql-persistent-connection/"/>
    <updated>2014-11-06T21:58:49+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/06/pdo-mysql-persistent-connection</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在 PHP 裡面如果使用 PDO 連接 Mysql 有個 <code>PDO::ATTR_PERSISTENT</code> 的選項可以形成 <code>persistent connection</code>，其中的機制是在 PHP script 結束的時候將連線交由背後的進程管理，
如果是使用 fastcgi 就會由 fastcgi 負責管理，另外從 <a href="http://eslizn.com/archives/39/">php持久化连接数据库</a> 的測試結果不管是用 apachehandle 或是 php-fpm 都可以支援持久化連線。</p>

<p>在 <a href="http://stackoverflow.com/questions/3332074/what-are-the-disadvantages-of-using-persistent-connection-in-pdo/5541150#5541150">What are the disadvantages of using persistent connection in PDO</a> 裡面有提到一些持久化連線會導致的問題值得一看，另外在最近同事使用持久化連線的時候遇到了 <code>MySQL server has gone away</code>
的問題，似乎是 PHP 端的持久化連線已經 lost 掉跟 mysql 的連線了但是卻沒有在次跟 mysql  重新連線的關係。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rabbitmq Auth Plugin]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/05/rabbitmq-plugin/"/>
    <updated>2014-11-05T22:49:35+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/05/rabbitmq-plugin</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在使用 rabbitmq 建立系統時，由於會將 rabbitmq 暴露在外層所以需要認證 client 是否合法，原本 rabbitmq 提供的認證方式並不適合讓
 client 都有自己的帳密進行認證，所以有想過撰寫一個中間層在 client 和 rabbitmq 之間進行認證，不過後來找到了 <a href="https://github.com/simonmacmullen/rabbitmq-auth-backend-http">rabbitmq-auth-backend-http</a>
 原來可以透過 rabbitmq plugin 擴增認證的方式，更仔細查詢似乎是跟 <code>SASL Authentication</code> 看來是 rabbitmq 已經有提供類似的機制給開發者了只是我沒有
 注意到而已。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[P2PSIP]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/04/p2psip/"/>
    <updated>2014-11-04T21:14:44+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/04/p2psip</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>簡介</h3>

<p>為了能夠建立去中心化的 SIP 網路，避免在傳統的 C/S 環境下由於一台 Server 失效的情況導致一個地區處於無法服務的狀態所設計的，
Skype 也是用 P2P 的方式建立它的通信網路，但是似乎不是使用 P2PSIP 的方式而是用它自己的方式實現，在網路上有些分析 Skype 通信協定的論文可以參考，
而 P2PSIP 本身有個<a href="http://www.p2psip.org/">官網</a>可以參考。</p>

<h3>P2P 和 SIP 協定結合的方式</h3>

<ol>
<li>SIP over P2P</li>
<li>P2P over SIP</li>
</ol>


<h3>函式庫</h3>

<p><a href="https://code.google.com/p/sip2peer/">sip2peer</a> 實現 P2PSIP 協定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coreos Docker]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/03/coreos-docker/"/>
    <updated>2014-11-03T21:06:19+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/03/coreos-docker</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://coreos.com/">coreos</a> 是基於 docker 可用來建立大型的運算平台的 linux 發行版本，從官網看來可以知道 coreos 是希望藉由建立群集然後在上面跑 docker 容器的方式
擴展整個平台， coreos 裡面除了有 docker 之外有兩個東西還蠻有趣的，一個是 etcd 另外一個是 fleet，這兩個都有開源在 github 上面。</p>

<h4>etcd</h4>

<p>etcd 類似 zookeeper 的東西能夠檢查伺服器是否存活，裡面使用了 Raft 的演算法。</p>

<h4>fleet</h4>

<p><a href="https://coreos.com/blog/cluster-level-container-orchestration/">Cluster-Level Container Deployment with fleet</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Erlang Web Servers]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/02/erlang-server/"/>
    <updated>2014-11-02T20:46:16+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/02/erlang-server</id>
    <content type="html"><![CDATA[<p>收集一些目前比較熱門的 Erlang Web Servers。</p>

<!-- more -->


<h3>Web Servers</h3>

<p>下面列一些比較活躍的項目，目前先使用 Mochiweb 練練手感，之前有用一個基於 Mochiweb + Rabbitmq 架設的聊天項目，感覺起來
還不錯，之後在看看之間的優缺點。。</p>

<h4>Mochiweb</h4>

<p><a href="https://github.com/mochi/mochiweb">mochiweb</a></p>

<h4>Cowboy</h4>

<p><a href="https://github.com/ninenines/cowboy">cowboy</a></p>

<h4>YAWS</h4>

<p><a href="https://github.com/klacke/yaws">yaws</a></p>

<h3>Web Framework</h3>

<p>有些 Web Framework 可以選擇，可以參考這篇<a href="https://github.com/ChicagoBoss/ChicagoBoss/wiki/Comparison-of-Erlang-Web-Frameworks">比較</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distributed Hash Table 理論]]></title>
    <link href="http://fubuki.github.io/blog/2014/11/01/distributed-hash-table/"/>
    <updated>2014-11-01T22:47:17+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/11/01/distributed-hash-table</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在許多 P2P 系統都有在使用 distributed hash table (DHT) 分享網路中的資訊。</p>

<h3>特性</h3>

<ol>
<li>Autonomy and Decentralization</li>
<li>Fault tolerance</li>
<li>Scalability</li>
</ol>


<h3>架構</h3>

<ol>
<li>Chord</li>
<li>Content-Addressable Network (CAN)</li>
<li>Global Information Sharing Protocol (GISP)</li>
<li>Kademlia</li>
<li>Pastry</li>
<li>Tapestry</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[十一月書單]]></title>
    <link href="http://fubuki.github.io/blog/2014/10/31/11-booklist/"/>
    <updated>2014-10-31T22:30:38+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/10/31/11-booklist</id>
    <content type="html"><![CDATA[<!-- more -->


<ol>
<li>P2P 技術完全攻略</li>
<li>Data.Science.at.the.Command.Line</li>
<li>企业集成模式.设计、构建及部署消息传递解决方案</li>
<li>高品質程式 軟體測試原則、實作與模式</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcached Repcached]]></title>
    <link href="http://fubuki.github.io/blog/2014/10/30/memcached-repcached/"/>
    <updated>2014-10-30T21:43:51+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/10/30/memcached-repcached</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近在看 memecached 架構的時候發現了一個名叫 <a href="http://repcached.lab.klab.org/">repcached</a> 的東西，似乎日本那邊基於 memecached 開發出來的擴充版本，
每台 memcached 都是 master 並且能夠互相同步，這邊有關於 repcached 的<a href="https://www.nic.ad.jp/ja/materials/iw/2008/proceedings/F2/IW2008-F2-08.pdf">說明</a>，跟之前使用 twemproxy 和 lib-memcached 擴展的方式不一樣，
可以研究一下其中的機制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Erlang 相關論文]]></title>
    <link href="http://fubuki.github.io/blog/2014/10/29/erlang-lun-wen/"/>
    <updated>2014-10-29T23:15:08+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/10/29/erlang-lun-wen</id>
    <content type="html"><![CDATA[<p>為了研究 erlang vm 尋找一些相關的論文。</p>

<!-- more -->


<p>目前應該會先讀1,2,7 這三篇論文，這三篇提到的東西我還蠻感興趣的，對於了解 erlang vm 應該會有不少幫助。</p>

<ol>
<li>Making reliable distributed systems in the presence of sodware errors</li>
<li>Characterizing the Scalability of Erlang VM on Many-core Processors</li>
<li>Exploring Alternative Memory Architectures for Erlang:Implementation and Performance Evaluation</li>
<li>Efﬁcient memory management for concurrent programs that use message passing I,II</li>
<li>Concurrent Programming in ERLANG</li>
<li>On Preserving Term Sharing in the Erlang Virtual Machine</li>
<li>Programming Distributed Erlang Applications:Pitfalls and Recipes</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[何謂 Back-to-back User Agent ?]]></title>
    <link href="http://fubuki.github.io/blog/2014/10/28/back-to-back-user-agent/"/>
    <updated>2014-10-28T23:49:06+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/10/28/back-to-back-user-agent</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在 RFC3261 裡面有定義何謂 Back-to-back user agent （B2BUA）? 是讓 client 端可以透過 B2BUA 使用 sip 協定建立連線，
然後必須要一直保持連線， 以角色來說就像  FreeSWITCH 一樣，就算是使用 sip 建立連線之後利用 rtp 傳送訊息似乎也需要
 FreeSWITCH 幫忙，我原本以為 FreeSWITCH 只是幫忙建立連線但從規格書上看還是需要 FreeSWTICH 參與對話。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Unique Id]]></title>
    <link href="http://fubuki.github.io/blog/2014/10/27/android-unique-id/"/>
    <updated>2014-10-27T22:59:45+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/10/27/android-unique-id</id>
    <content type="html"><![CDATA[<p>如何取得 android 裝置的唯一編號。</p>

<!-- more -->


<p>目前有一些用來識別是否為同一個裝置的方法，不過都有各自的問題。</p>

<ol>
<li><p>Mac Address
在沒有 wifi 或是沒有開啟 wifi 的裝置就無法取得 Mac Address。</p></li>
<li><p>DeviceId(IMEI/MEID/ESN)
非手機裝置會沒有 DeviceId，另外似乎有些產品會返回 null。</p></li>
<li><p>Android ID
有些廠商的裝置會有相同的 Android ID，但是是哪些廠商我就沒有看過有人寫出來。</p></li>
<li><p>Serial Number
在 2.3之後的版本可以透過 android.os.Build.SERIAL 取得 Serial Number，似乎需要 READ_PHONE_STATE的權限，</p></li>
<li><p>UUID
開發者可以在 APP 安裝時產生 UUID，但是就必須考慮到如何保存 UUID 的數值。</p></li>
</ol>


<p>參考:<br/>
<a href="http://android-developers.blogspot.tw/2011/03/identifying-app-installations.html">Identifying App Installations</a><br/>
<a href="http://www.pocketmagic.net/2011/02/android-unique-device-id/">Android Unique Device ID</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[控制 PHP 執行時間]]></title>
    <link href="http://fubuki.github.io/blog/2014/10/26/php-timeout/"/>
    <updated>2014-10-26T13:38:11+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/10/26/php-timeout</id>
    <content type="html"><![CDATA[<p>如何控制 PHP 的最長執行時間。</p>

<!-- more -->


<p>在執行 PHP 腳本的時候有可能因為程式邏輯上的問題或是為了取得外部的資料導致執行時間過久，而讓使用者等待回應的時間過長帶來不好的體驗，
因此在 PHP 本身一些常用的函式庫或是伺服器設定會讓開發者設定 timeout 的時間。</p>

<h4>nginx</h4>

<ol>
<li>fastcgi_connect_timeout</li>
<li>fastcgi_send_timeout</li>
<li>fastcgi_read_timeout</li>
</ol>


<h4>php-fpm</h4>

<ol>
<li>php-fpm.conf 的 request_terminate_timeout</li>
</ol>


<p>max_execution_time 和 set_time_limit 也能限制腳本執行的時間但是似乎在某些場景是有問題的。</p>

<h4>curl</h4>

<ol>
<li>CURLOPT_TIMEOUT</li>
<li>CURLOPT_TIMEOUT_MS</li>
<li>CURLOPT_CONNECTTIMEOUT</li>
<li>CURLOPT_CONNECTTIMEOUT_MS</li>
<li>CURLOPT_DNS_CACHE_TIMEOUT</li>
</ol>


<h4>mysql</h4>

<ol>
<li>innodb_lock_wait_timeout</li>
<li>libmysql 的 MYSQL_OPT_READ_TIMEOUT 和 MYSQL_OPT_WRITE_TIMEOUT</li>
</ol>


<h4>memcached</h4>

<ol>
<li>bool Memcache::connect ( string $host [, int $port [, int $timeout ]] )</li>
<li>Memcached 要另外實現</li>
</ol>


<h4>redis</h4>

<ol>
<li>$redis->connect(&lsquo;127.0.0.1&rsquo;, 6379, 2.5); // 2.5 sec timeout.</li>
<li>$redis->pconnect(&lsquo;127.0.0.1&rsquo;, 6379, 2.5, &lsquo;x&rsquo;); // x is sent as persistent_id and would be another connection the the three before.</li>
</ol>


<h4>其他</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Facebok Messenger 的 新架構]]></title>
    <link href="http://fubuki.github.io/blog/2014/10/25/mqtt-and-thrift/"/>
    <updated>2014-10-25T22:44:32+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/10/25/mqtt-and-thrift</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Facebook 更改他們的 Messageer 的背後架構，在 <a href="https://code.facebook.com/posts/820258981365363/building-mobile-first-infrastructure-for-messenger/">Building Mobile-First Infrastructure for Messenger</a> 一文中有提到做了哪些更改並且提到更改後提升的多少效能。</p>

<p>裡面其中一個引我注意的是使用 mqtt + thrift 和 iris，工作上原本有使用 mqtt 當作 server 與 client 之間溝通的協定，但是在傳輸量上面希望能夠在縮減一些，目前看到有人提到 mqtt + protobuf 和 mqtt + thrift，主要都是使用 mqtt 載體然後利用其他方式壓縮訊息內容，Facebook 似乎是用 thrift 壓縮訊息內容，也許可以嘗試看看。</p>

<p>另外一個是 Facebook 採用 &lsquo;push-based snapshot + delta model&#8217;，這個 model 是使用 iris 實現，似乎是一種 message queue，裡面有兩個指針指向 APP 最後收到的訊息和 server 最新收到的訊息，之前有計畫寫個類似的東西用來存放使用者訊息，也許可以參考一下 Facebook 的架構。</p>
]]></content>
  </entry>
  
</feed>
