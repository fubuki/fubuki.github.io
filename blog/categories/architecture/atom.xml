<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Categories: Architecture | Learning Blog]]></title>
  <link href="http://fubuki.github.io/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2015-08-02T23:11:02+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CQRS 不同的應用方法]]></title>
    <link href="http://fubuki.github.io/blog/2015/07/26/cqrs-but-different/"/>
    <updated>2015-07-26T23:24:10+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/07/26/cqrs-but-different</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://vimeo.com/131199089">CQRS – but different - Udi Dahan</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RebirnDB 架構]]></title>
    <link href="http://fubuki.github.io/blog/2015/07/16/rebirndb/"/>
    <updated>2015-07-16T20:31:38+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/07/16/rebirndb</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://github.com/reborndb/reborn">RebornDB</a> 一個分散式 key-value 資料庫。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CQRS Architecture]]></title>
    <link href="http://fubuki.github.io/blog/2015/06/23/cqr-architecture/"/>
    <updated>2015-06-23T00:52:40+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/06/23/cqr-architecture</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近在研究一些秒殺活動的架構，看到有人提到 <a href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> 這種模式，之前看過國外在金融系統上使用 LMAX 的架構
其實就是一種 <a href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> 模式也就是讀寫分離，讀取和寫入分成兩種架構，然後使用像是 LMAX 裡面提到的 EVENT SOURCE 的模式，
類似 git 裡面的 commit 的概念，將所有的修改視為一種事件存放起來。</p>

<p>這樣的模式通常我會使用 message queue 存放寫入的事件然後利用多個 worker 處理這些寫入事件將資料直接寫入資料庫，所以在某些情形
下負責讀取資料的部分可能會因為延遲寫入導致會查詢不到一些資料。</p>

<p>有些記錄可能會大量更新，哪些部分就放在記憶體中處理，如果有遇到當機之類的災難可能要從 message queue 的部分將資料重新寫回記憶體，
所以有可能需要就 message queue 的事件另外存放一段時間直到資料都寫回到資料庫裡。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quora Architecture]]></title>
    <link href="http://fubuki.github.io/blog/2015/05/12/quora-architecture/"/>
    <updated>2015-05-12T22:51:08+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/05/12/quora-architecture</id>
    <content type="html"><![CDATA[<!-- more -->


<ol>
<li><a href="http://www.quora.com/How-does-Quoras-parallel-rendering-architecture-work">How does Quora&rsquo;s parallel rendering architecture work?</a></li>
<li><a href="http://blog.quora.com/Improving-Site-Speed">Improving Site Speed</a></li>
<li><a href="http://engineering.quora.com/Web-Server-Architecture-at-Quora">Web Server Architecture at Quora</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stack Overflow 的架構]]></title>
    <link href="http://fubuki.github.io/blog/2015/02/10/stack-overflow-de-jia-gou/"/>
    <updated>2015-02-10T23:00:17+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/02/10/stack-overflow-de-jia-gou</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Stack Overflow 是很有名的程式設計師用的問答網站， 下面兩篇文章介紹 Stack Overflow 怎麼使用 25 台伺服器撐起整個服務。</p>

<ol>
<li><a href="http://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow/">What it takes to run Stack Overflow</a></li>
<li><a href="http://www.dev-metal.com/architecture-stackoverflow/">The architecture of StackOverflow</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
