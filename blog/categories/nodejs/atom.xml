<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Categories: Nodejs | Learning Blog]]></title>
  <link href="http://fubuki.github.io/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2016-03-25T23:49:58+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NodeOS: node.js Operation System]]></title>
    <link href="http://fubuki.github.io/blog/2016/02/06/nodeos/"/>
    <updated>2016-02-06T22:55:31+08:00</updated>
    <id>http://fubuki.github.io/blog/2016/02/06/nodeos</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://github.com/NodeOS/NodeOS">NodeOS</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在 2016 年成為更好的 Node.js 開發者]]></title>
    <link href="http://fubuki.github.io/blog/2016/01/14/node-dot-js-2016/"/>
    <updated>2016-01-14T23:29:08+08:00</updated>
    <id>http://fubuki.github.io/blog/2016/01/14/node-dot-js-2016</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://blog.risingstack.com/how-to-become-a-better-node-js-developer-in-2016/">How to Become a Better Node.js Developer in 2016</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Download Npm on Offline Status]]></title>
    <link href="http://fubuki.github.io/blog/2016/01/05/offline-npm/"/>
    <updated>2016-01-05T22:16:08+08:00</updated>
    <id>http://fubuki.github.io/blog/2016/01/05/offline-npm</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://addyosmani.com/blog/using-npm-offline/">Offline installation of npm packages</a></p>

<ol>
<li>local-npm</li>
<li>npm_lazy</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[註解長度跟 Nodejs 效能關係]]></title>
    <link href="http://fubuki.github.io/blog/2015/10/25/nodejs-a-quick-optimization-advice/"/>
    <updated>2015-10-25T22:13:34+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/10/25/nodejs-a-quick-optimization-advice</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://top.fse.guru/nodejs-a-quick-optimization-advice-7353b820c92e#.99rjxrtk1">#NodeJS : A quick optimization advice</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[node.js 建立 Child Process]]></title>
    <link href="http://fubuki.github.io/blog/2015/02/23/node-dot-js-child-process/"/>
    <updated>2015-02-23T22:49:18+08:00</updated>
    <id>http://fubuki.github.io/blog/2015/02/23/node-dot-js-child-process</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近在測試將手上一個 node.js 的系統分成好幾個子系統，然後主要的系統就只是去監控子系統
避免當子系統出現問題時導致整個系統出現問題，這邊紀錄一下 node.js 怎麼建立 child process。</p>

<p>以前有用過 node.js 的 cluster 模組去擴展 socket.io 的伺服器，現在是用 <code>child process</code> 模組建立
新的 process 收到處理完成的訊息後就將 process 給殺掉， <code>child process</code> 目前有提供下面幾種方法。</p>

<ol>
<li>spawn</li>
<li>exec</li>
<li>execFile</li>
<li>fork</li>
</ol>

]]></content>
  </entry>
  
</feed>
