<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Categories: Nodejs | Learning Blog]]></title>
  <link href="http://fubuki.github.io/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2014-04-24T23:32:54+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[socket.io Port問題]]></title>
    <link href="http://fubuki.github.io/blog/2014/04/24/socket-dot-io-portwen-ti/"/>
    <updated>2014-04-24T23:09:10+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/04/24/socket-dot-io-portwen-ti</id>
    <content type="html"><![CDATA[<p>前端連接socket.io server遇到port問題的解決方法。</p>

<!-- more -->


<h3>haproxy</h3>

<p><a href="http://blog.davidmisshula.com/blog/2013/02/04/configure-haproxy-to-scale-multiple-nodes-with-stickiness-and-ssl/">configure-haproxy-to-scale-multiple-nodes-with-stickiness-and-ssl</a> <br/>
<a href="http://blog.carbonfive.com/2013/05/02/using-haproxy-with-socket-io-and-ssl/">using-haproxy-with-socket-io-and-ssl</a>  <br/>
這個方法有在Centos上面實作過是可行的，網路也有不少設定可以參考，不過當初只有測試websocket的方法。</p>

<h3>nginx</h3>

<p><a href="http://blog.mixu.net/2011/08/13/nginx-websockets-ssl-and-socket-io-deployment/">nginx-websockets-ssl-and-socket-io-deployment</a><br/>
nginx在1.3之後支援websocket可以最為反向代理，這個方法沒有實測過。</p>

<h3>透過改寫xhr-polling</h3>

<p><a href="http://stephenbelanger.com/2011/09/21/how-to-make-socket-io-work-behind-nginx-mostly/">how-to-make-socket-io-work-behind-nginx-mostly</a>  <br/>
這個方法是改寫xhr-polling的方法，前端就可以不用加上port就可以直接連接server，但是就不能使用其他的
連接方法了吧?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[node.js 0.12 版本]]></title>
    <link href="http://fubuki.github.io/blog/2014/04/16/node-dot-js-0-dot-12-ban-ben/"/>
    <updated>2014-04-16T23:18:11+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/04/16/node-dot-js-0-dot-12-ban-ben</id>
    <content type="html"><![CDATA[<p>nodejs 0.12版本出來了，多了一些新的API，改進Cluster的功能此外ES6 的特性在0.11.9也可以開啟使用。</p>

<!-- more -->


<h3>Cork support for writable streams</h3>

<p>這邊是提升tcp傳輸的效率，當數據流裡面的小數據結合成大數據在送出減少tcp和系統的調用。</p>

<h3>tls module</h3>

<p>原本nodejs的tls模塊的效率提高了，之前有使用過http模組的tls功能不過沒有測試過他的效率。</p>

<h3>Crypto performance improvements</h3>

<p>改進加解密演算法的速度，不過我比較常用的主要在session方面的加密</p>

<h3>Reduced garbage collector strain</h3>

<p>0.12版本改寫了關於context的部分<a href="https://github.com/joyent/node/commit/756b622">multi-context refactoring</a>，藉此減少v8在multi-context的情形下，
不會讓V8一直處理關於handle的問題。</p>

<h3>Better cluster performance</h3>

<p>這個改進我有可能比較常用到，目前在作nodejs applicacion的架構優化並且希望機器的資源能充分使用，然後這篇<a href="http://strongloop.com/strongblog/whats-new-in-node-js-v0-12-cluster-round-robin-load-balancing/">post</a>有提到
如何改進cluster的效率。</p>

<h3>Faster timers, faster setImmediate(), faster process.nextTick()</h3>

<p>這部分是提升像是setTimeout之類API的效率，這裡就不太清楚了。</p>

<p>原文在此<a href="http://strongloop.com/strongblog/performance-node-js-v-0-12-whats-new/">node-js-v-0-12-whats-new</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodejs Flow Control]]></title>
    <link href="http://fubuki.github.io/blog/2014/04/06/nodejs-flow-control/"/>
    <updated>2014-04-06T16:22:06+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/04/06/nodejs-flow-control</id>
    <content type="html"><![CDATA[<p>記錄一下流程控制相關的模組。<br/>
1. <a href="https://github.com/creationix/step">step</a> <br/>
2. <a href="https://github.com/kriskowal/q">Q</a><br/>
3. <a href="https://github.com/kriszyp/node-promise">promise</a></p>

<!-- more -->


<p>由於nodejs是非同步的，所以流程控制是很重要的一部分，一般撰寫程式時會等待其他區塊的回傳參數，但是由於非同步的關係所以需要以嵌套的方式
避免所需要的參數尚未回傳就執行下一步的函式導致未知的結果，如此一來就會出現多重嵌套的情形導致程式以後變的難以除錯並且看起來也很醜，所以
有些人提供一些第三方的模組處理流程控制的部分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nodejs 生產環境]]></title>
    <link href="http://fubuki.github.io/blog/2014/04/05/nodejs-sheng-chan-huan-jing/"/>
    <updated>2014-04-05T21:55:23+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/04/05/nodejs-sheng-chan-huan-jing</id>
    <content type="html"><![CDATA[<p>記錄一下nodejs生產環境需要注意的事項。</p>

<!-- more -->


<ol>
<li>nodejs是非同步但是也有一些同步的API(例如讀取檔案)會影響nodejs的運行，要小心使用那些API。</li>
<li>nodejs底層是使用V8引擎可以藉由調整V8的GC策略提升效能。</li>
<li>nodejs建立socket時增加可以建立的socket的數量。</li>
<li>nodejs 有些使用模組是編譯過的，有些是純js撰寫成的，使用二進位編譯後的模組。</li>
<li>在nodejs中事件流的處理會影響程式效能，目前有些用來處理事件流的模組慎選並去使用。</li>
<li>nodejs的session通常使用express處理，預設存放在記憶體內，建議替換到redis或是memcache的資料庫存放。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[exports和module.export區別]]></title>
    <link href="http://fubuki.github.io/blog/2014/03/24/exportshe-module-dot-exportqu-bie/"/>
    <updated>2014-03-24T21:19:20+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/03/24/exportshe-module-dot-exportqu-bie</id>
    <content type="html"><![CDATA[<p>exports和module.export 在一些library常看到這兩種東西，有些情況下是相同的，
去查網路都有推薦<a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html">Node.js Module – exports vs module.exports</a>這篇文章。</p>
]]></content>
  </entry>
  
</feed>
