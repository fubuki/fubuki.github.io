<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Categories: Php | Learning Blog]]></title>
  <link href="http://fubuki.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2014-08-10T23:59:13+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PHP 自動化測試]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/23/php-zi-dong-hua-ce-shi/"/>
    <updated>2014-07-23T23:42:22+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/23/php-zi-dong-hua-ce-shi</id>
    <content type="html"><![CDATA[<p>關於 PHP 自動化測試部分。</p>

<!-- more -->


<p><a href="http://phpunit.de/">浅析 PHP 官方自动化测试方法</a>
<a href="https://github.com/sebastianbergmann/phpunit-selenium">phpunit-selenium</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Restart Php Script by Register_shutdown_function and Pcntl_exec]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/07/register-shutdown-function-and-destructor/"/>
    <updated>2014-07-07T23:07:53+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/07/register-shutdown-function-and-destructor</id>
    <content type="html"><![CDATA[<p>在使用PHP CLI 跑背景程式有時候會因為記憶體溢出或是其他原因導致程式停止執行，需要讓程式自行重新啟動。</p>

<!-- more -->


<p>register_shutdown_function 是可以讓PHP在意外終止的時候可以去執行特定函式，配合 <code>pcntl_exec()</code> 便可以
完成當程式發生FatalError 時可以自動重新啟動。</p>

<script src="https://gist.github.com/fubuki/e621eb4844a975b9c0e1.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Php-fpm 優化參數]]></title>
    <link href="http://fubuki.github.io/blog/2014/07/01/php-fpm-you-hua-can-shu/"/>
    <updated>2014-07-01T23:30:29+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/07/01/php-fpm-you-hua-can-shu</id>
    <content type="html"><![CDATA[<p>warning pool www child exited on signal 9 (sigkill) after seconds from start</p>

<!-- more -->


<p>php-fpm管理進程的模式有靜態和動態，差別在於靜態會根據參數直接生成固定的進程，動態則是會動態調整所需要的進程，
選擇哪個模式端看於硬體上記憶體大小的差別。</p>

<h2>靜態或是動態</h2>

<p>pm = static or dynamic</p>

<h2>靜態方法</h2>

<p>pm.max_children : php-fpm 最大進程數</p>

<h2>動態方法</h2>

<p>pm.start_servers : php-fpm 一開始創鍵的進程數</p>

<p>pm.min_spare_servers : php-fpm 最小的進程數</p>

<p>pm.max_spare_servers : php-fpm 最大進程數</p>

<h2>其他參數</h2>

<p>pm.max_requests : 一個進程處理多少個請求後就重新啟動</p>

<h2>參數大小設定規則</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP 之 Fastcgi_finish_request]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/29/php-zhi-fastcgi-finish-request/"/>
    <updated>2014-06-29T23:02:40+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/29/php-zhi-fastcgi-finish-request</id>
    <content type="html"><![CDATA[<p>PHP 在 fast-cgi 模式下有一個有趣的函式 <code>fastcgi_finish_request</code> 可以使用，在<a href="http://php.net/manual/en/function.fastcgi-finish-request.php">function.fastcgi-finish-request</a>
有說明這個函式是讓開發者強制停止與客戶端之間的連線，但是服務端的腳本還是持續執行，這讓客戶端可以不用等待一些耗時的操作，
不過如果要達成類似的效果我還是比較喜歡用丟到隊列去執行的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP 內核研究資源]]></title>
    <link href="http://fubuki.github.io/blog/2014/06/02/php-he-yan-jiu-zi-yuan/"/>
    <updated>2014-06-02T23:50:44+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/06/02/php-he-yan-jiu-zi-yuan</id>
    <content type="html"><![CDATA[<p>深入理解PHP内核 <a href="http://www.php-internals.com/book/">http://www.php-internals.com/book/</a></p>
]]></content>
  </entry>
  
</feed>
