<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Categories: Linux | Learning Blog]]></title>
  <link href="http://fubuki.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://fubuki.github.io/"/>
  <updated>2014-12-24T23:43:16+08:00</updated>
  <id>http://fubuki.github.io/</id>
  <author>
    <name><![CDATA[Fubuki]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[分析 Vmcore 和 vmcore-dmesg.txt]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/22/vmcore-dmesg-dot-txt/"/>
    <updated>2014-12-22T23:11:07+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/22/vmcore-dmesg-dot-txt</id>
    <content type="html"><![CDATA[<!-- more -->


<p>今天在試玩 docker 的時候，因為不知名因素導致系統直接重啟，後來發現是整個內核 crash 原因是似乎是跟 <code>device-mapper</code> 脫不了關係，
看他 console 列出的最後訊息可以得知在 <code>/var/crash</code> 生成了兩個文件: <code>vmcore</code> 和 <code>vmcore-dmesg.txt</code>。</p>

<p>在 <code>/var/crash</code> 下面的兩個文件是記錄了系統 Crash 時的最後訊息，可以透過這些文件追蹤發生了什麼事，要追蹤需要使用幾個工具: kdump 和 crash
，kdump 是讓系統 Crash 時將內核的訊息 dump 到硬碟上以供使用者除錯， crash 是可以去分析 <code>vmcore</code> 的內容，但是需要 vmlinux 的檔案才能分析
 vmcore 的內容， vmlinux 需要跟目前的系統核心相同。</p>

<p> 另外一個 vmcore-dmesg.txt 檔案是記錄一些系統資訊和 Crash 時的資訊，雖然沒有比 vmcore 詳細但是也可以作為參考，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[添加 Flv Keyframes 支持拖動撥放]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/19/nginx-yamdi-flvtool/"/>
    <updated>2014-12-19T22:36:50+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/19/nginx-yamdi-flvtool</id>
    <content type="html"><![CDATA[<!-- more -->


<p>目前在研究在多種裝置上面支援播放影片，目前看到有使用下面幾種方式:</p>

<ol>
<li>RTMP/RTMPT</li>
<li>RTSP</li>
<li>HTTP</li>
<li>MMS</li>
<li>HLS</li>
</ol>


<p>而手上有 mp4 和 flv 以及 m3u8 三種格式需要播放，目前是先選用 nginx 透過 HTTP 播放這樣需要安裝的套件比較少，
如果要使用 CDN 擴展也比較方便，但是除了原本的 m3u8 格式可以支援拖動撥放，另外兩個要使用其他工具添加 keyframes 才能讓
播放器不需要載入全部檔案就可以撥放，下面記錄目前有使用哪些工具添加 keyframes。</p>

<h3>flv</h3>

<ol>
<li><a href="http://yamdi.sourceforge.net/">yamdi</a></li>
<li><a href="https://github.com/Elbandi/flvtool-pp">flvtool++</a></li>
</ol>


<h3>mp4</h3>

<ol>
<li><a href="https://github.com/danielgtaylor/qtfaststart">qtfaststart</a></li>
<li>MP4Box</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Centos 6 安裝 Ffmpeg Flvtool++ Qtfaststart]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/18/ffmpeg-flvtool-plus-plus-qtfaststart/"/>
    <updated>2014-12-18T22:43:14+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/18/ffmpeg-flvtool-plus-plus-qtfaststart</id>
    <content type="html"><![CDATA[<!-- more -->


<h4>ffmpeg</h4>

<p>在 Centos 上面使用 yum 安裝的 ffmpeg 版本都太舊了，版本只有到 0.6 而已目前最新已經到 2.5 了，
另外使用 yum 安裝的 ffmpeg 似乎沒有把一些我需要的編碼加進去導致沒有支援 flv 的轉碼。</p>

<p>目前看到網路上有很多教程解說如何從原始碼安裝 ffmpeg ，但是在編譯的時候在跑 x264 的時候就沒有辦法通過編譯
，最後參考這篇 <a href="http://wiki.razuna.com/display/ecp/FFMpeg+Installation+on+CentOS+and+RedHat">Install FFMpeg</a> 才能編譯過去。看起來也許是之前的函式庫沒有移除乾淨所導致的。</p>

<p>下面兩個是讓 mp4 和 flv 檔案可以透過 http 的方式拖動撥放</p>

<h4>qtfaststart</h4>

<p><a href="https://github.com/danielgtaylor/qtfaststart">qtfaststart</a> 是用來轉 mp4 的相關工具，直接透過 pypi 安裝即可。</p>

<pre><code>easy_install qtfaststart
</code></pre>

<h4>flvtool++</h4>

<p>網路上有 <a href="https://github.com/Elbandi/flvtool-pp">flvtool++</a> 和 flvtool2 這兩者似乎是類似的東西用來處理 flv 檔案， yum 源裡面是有 flvtool2
<a href="https://github.com/Elbandi/flvtool-pp">flvtool++</a> 只能自行編譯安裝。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[管理 Linux 啟動執行的服務]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/13/linux-start-service/"/>
    <updated>2014-12-13T23:09:26+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/13/linux-start-service</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在 Liinux 使用 <code>update--rc.d</code> 或是 <code>chkconfig</code> 管理開機時要啟動哪些服務，兩者用法是類似的，
另外還有 Ubuntu 底下也有 <code>rcconf</code> 和 <code>sysv-rc-conf</code> 可以使用，不過上面的指令會提到關於執行 level 的概念
決定服務要在哪個時候執行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[讓 Crontab 執行 30 秒任務]]></title>
    <link href="http://fubuki.github.io/blog/2014/12/07/crontab-second/"/>
    <updated>2014-12-07T10:48:17+08:00</updated>
    <id>http://fubuki.github.io/blog/2014/12/07/crontab-second</id>
    <content type="html"><![CDATA[<!-- more -->


<p>crontab 是 linux 用來執行定時任務的指令，但是他最多只能指定到分，如果要有設定 30 秒執行的任務就要比較特殊的做法。</p>

<p>使用 sleep 指令延遲 30 秒執行，這樣就可以達成每 30 秒執行任務的功能。</p>

<pre><code>* * * * * ntpdate -s time.stdtime.gov.tw
* * * * * sleep 30 &amp;&amp;  ntpdate -s time.stdtime.gov.tw
</code></pre>
]]></content>
  </entry>
  
</feed>
